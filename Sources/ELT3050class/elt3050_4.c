
/*
  
;*****************************************************************************
Name      Program title
;-----------------------------------------------------------------------------
Create a program that will blink LED 1 continuously at 10 Hz and LED 2 at 15Hz.  
LED 2 will use the systick interrupt while LED 1 will use simple delays in the 
mainloop.  If PB1 is pushed in it will cause a PORTA1 interrupt on the falling 
edge.  It will toggle the state of led3 then return to the main loop.
;------------------------------------------------------------------------------
;SUBROUTINES/FUNCTIONS/INTERRUPT ROUTINES: 

  
;-------------------------------------------------------------------------------
;Input/Output


;------------------------------------------------------------------------------
;VARIABLES:

;*****************************************************************************

*/


#include "derivative.h" /* include peripheral declarations */
#include "my_io_apps.c" /* include peripheral declarations */
#include "arm_cm0.h"
//#include "my_interrupts.c"


/******* Prototype Function declarations ******/
void syst_tick_init(void);
void init_port_interrupt_a1(char);


/**************Global Variables Here************************/
volatile int sys_ticks=0;
/***********************************************************/
int main(void) {
 
//*******Local Variable Declarations for main *****************

//******Initial Chip Settings******************

//  The student user should not make changes here unless
//explicitly instructed to do so
int pll_err=pll_init(8000000,0,1,4,24,1);     //Use the crystal oscillator to drive the PLL

//******User chip module initializations***************************************
     init_leds();
     init_pbs();
     syst_tick_init();
     init_port_interrupt_a1(2);    //falling edge interrupt

    

//*************The infinte loop.  Could use while(1);	
	for(;;) {
		
		gpo_c(0,1);
		delay_ms(50);
		gpo_c(0,0);
		delay_ms(50);
				
		
			
		}
	return 0;
    }



/***********************Systick Interrupt******************
 This interrupt requires an initialization.  It is a CPU interrupt 
 on the ARMcore M0+ module, not the K25Z.  Once activated with 
 the initialization it will generate a SysTick_Handler interrupt every 1ms.  
*/ 
void syst_tick_init(void){
/*void syst_tick_init(char x){    //lets implement this at some point to get more flexibility from sys_tick   
		SYST_RVR=48*x;    //This is the counter modulus or reset value.  	*/
	
	SYST_RVR=48000;    //This is the counter modulus or reset value.  
	//The processor clock is 48MHz so counting up to 48000 should take 1ms
	
	//SYST_RVR=0xffffff;    //The RVR can only hold 24 bits or 16M.  Thus,
	                      //the longest we can delay is 16M/48M ~ .25s

	SYST_CVR=0;        //this is the actual counter.. must be initialized 
	                   //to 0 to start       
	SYST_CSR=0x7;       //use the processor clock/enable exceptions when 
	                   //CVR=0/enable systick
	 
}
 
/****************SysTick_Handler*********************************
This occurs when enabled in sys tick int.

freq = f bus clock / RVR

The ticks variable should increment every  SYST_RVR / 48MHz seconds. 
 Ex. A value SYST_RVR=48000 should take 1ms.*/

void SysTick_Handler(void){
	static char j=0;
	sys_ticks++;
	
	if (sys_ticks>100){
		j^=1;
		gpo_c(1,j);
		sys_ticks=0;
	}
			
}

/*****************************************************************************************************
 *              Init portn interrupt_nx(char edge)
 *              
 * These interrupts are activated by edges on parallel port pins.  
 * 
 * n:  a,d   only
 * 
 * x: number 0-31
 * 
 * edge: 0 turn off the interrupt
 *       1 rising edge
 *       2 falling edge
 *       3 rising and falling edge
 * The pin initialization function 
 * 
 * init_gpio_a is called to create an input pin.
 * 
 * To create another interrupt for pin d3, for example
 * 
 * replace  PORTA_PCR(1)  with PORTD_PCR(3)
 * 
 * 
 * */
void init_port_interrupt_a1(char edge){
	
	init_gpio_a(1,0);
	if(edge==1)PORTA_PCR(1)|=PORT_PCR_IRQC(0b1001);
	else if(edge==2)PORTA_PCR(1)|=PORT_PCR_IRQC(0b1010);
	else if(edge==3)PORTA_PCR(1)|=PORT_PCR_IRQC(0b1011);
	else PORTA_PCR(1)|=PORT_PCR_IRQC(0);
			
	
	
    enable_irq (INT_PORTA-16);  //This sets the NVIC_ICPR and NVIC_ISER registers declaring the interrupt 			
 //   set_irq_priority (INT_PORTA-16,0);
} 


/***********************************************************************
 *                    PORTA_IRQHandler                                  
 ***********************************************************************
 This is the IRQ routine for the interrupt generated by some action on pinA1
 
 It will perform this routine whenever the action specified in the initialization
 occurs.  The initialization is set to interrupt on either a rising, falling or either
 type of edge.
 
 Before exiting the routine the interrupt flag ISF flag is cleared by writing a 1 to it.
 ************************************************************************/

void PORTA_IRQHandler()
{
	static char i=0;
	delay_ms(10);
	  i^=1;
	  gpo_c(2,i);
	while(!(gpi_a(1)));
	delay_ms(10);
 /*****You must include this step clearing the interrupt flag.  Don't remove*******/
 PORTA_PCR(1)|=PORT_PCR_ISF_MASK;
/***********************************************************************************/
}




