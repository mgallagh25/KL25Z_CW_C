/*
 * Generates a pulse train based on the AtD value from the potentiometer on the FRDM1.2 shield.
 * 
 * analog value AtD E20
 * Pulses     C1
 *
 */





#include "derivative.h" /* include peripheral declarations */
#include "my_io_apps.c" /* include peripheral declarations */
#include "mcg.h" /* using XTAL and PLL does not work returns errors*/

//#include "my_interrupts.c"     // these functions are put in the main file for convenience

#include "my_timer_apps.c"

#include "my_lcd.c" /* include lcd declarations */
/**************function prototype declarations********/
void init_port_interrupt_a1(char);
void PORTA_IRQHandler();
void syst_tick_init(void);
void SysTick_Handler(void);

/**************Global Variables Here************************/

int x=0;
int sys_ticks_temp=0;
volatile int sys_ticks=0;


int main(void) {
 
	//*******Local Variable Decalrations for main *****************
		char i=0;
	//******Initial Chip Settings******************

	//  The student user should not make changes here unless
	//explicitly instructed to do so
	          int pll_err=pll_init(8000000,0,1,4,24,1);     //Use the crystal oscillator to drive the PLL

	//******User chip initializations***************************************

	          init_port_interrupt_a1(2);
	          syst_tick_init();
	          
	          //init_gpio_a(1,0);
	          init_gpio_a(2,0);
	          init_gpio_a(4,0);
	          init_gpio_a(5,0);
	          	    
	          init_gpio_c(1,1);
	      	  gpo_c(1,1);
	          init_gpio_c(0,1);
	          gpo_c(0,1);
	for(;;) {	 
		
	  gpo_c(0,0);
	   delay_100us(1000);    //5Hz  200ms or Ton=100ms
	  gpo_c(0,1);
	  delay_100us(1000);
	  
		
	}
	
	return 0;
    }

/***********************Systick Interrupt******************
 This interrupt requires an initialization.  It is a CPU interrupt 
 on the ARMcore M0+ module, not the K25Z.  Once activated with 
 the initialization it will generate a SysTick_Handler interrupt every 1ms.  
*/ 
void syst_tick_init(void){
/*void syst_tick_init(char x){    //lets implement this at some point to get more flexibility from sys_tick   
		SYST_RVR=48*x;    //This is the counter modulus or reset value.  	*/
	
	SYST_RVR=48000;    //This is the counter modulus or reset value.  
	//The processor clock is 48MHz so counting up to 48000 should take 1ms
	
	//SYST_RVR=0xffffff;    //The RVR can only hold 24 bits or 16M.  Thus,
	                      //the longest we can delay is 16M/48M ~ .25s

	SYST_CVR=0;        //this is the actual counter.. must be initialized 
	                   //to 0 to start       
	SYST_CSR=0x7;       //use the processor clock/enable exceptions when 
	                   //CVR=0/enable systick
	 
}
 
/****************SysTick_Handler*********************************
This occurs when enabled in sys tick int.

freq = f bus clock / RVR

The ticks variable should increment every  SYST_RVR / 48MHz seconds. 
 Ex. A value SYST_RVR=48000 should take 1ms.*/

void SysTick_Handler(void){
	
	sys_ticks++;
		
	
}



/*****************************************************************************************************
 *              Init portn interrupt_nx(char edge)
 *              
 * These interrupts are activated by edges on parallel port pins.  
 * 
 * n:  a,d   only
 * 
 * x: number 0-31
 * 
 * edge: 0 turn off the interrupt
 *       1 rising edge
 *       2 falling edge
 *       3 rising and falling edge
 * The pin initialization function 
 * 
 * init_gpio_a is called to create an input pin.
 * 
 * To create another interrupt for pin d3, for example
 * 
 * replace  PORTA_PCR(1)  with PORTD_PCR(3)
 * 
 * 
 * */
void init_port_interrupt_a1(char edge){
	
	init_gpio_a(1,0);
	if(edge==1)PORTA_PCR(1)|=PORT_PCR_IRQC(0b1001);
	else if(edge==2)PORTA_PCR(1)|=PORT_PCR_IRQC(0b1010);
	else if(edge==3)PORTA_PCR(1)|=PORT_PCR_IRQC(0b1011);
	else PORTA_PCR(1)|=PORT_PCR_IRQC(0);
			
    enable_irq (INT_PORTA-16);  //This sets the NVIC_ICPR and NVIC_ISER registers declaring the interrupt 			
} 


/***********************************************************************
 *                    PORTA_IRQHandler                                  
 ***********************************************************************
 This is the IRQ routine for the interrupt generated by some action on pinA1
 
 It will perform this routine whenever the action specified in the initialization
 occurs.  The initialization is set to interrupt on either a rising, falling or either
 type of edge.
 
 Before exiting the routine the interrupt flag ISF flag is cleared by writing a 1 to it.
 ************************************************************************/

void PORTA_IRQHandler()
{
	static char i=0;
	delay_100us(100);
	  i^=1;
	  gpo_c(1,i);
	 
 /*****You must include this step clearing the interrupt flag.  Don't remove*******/
 PORTA_PCR(1)|=PORT_PCR_ISF_MASK;
/***********************************************************************************/
}

